{
  "id": 10,
  "module": "sys",
  "slug": "distributed-locks-and-coordination",
  "title": "Distributed Locks & Coordination",
  "topics": [
    "Lease-based locking",
    "Quorum coordination",
    "Fencing tokens",
    "Consensus"
  ],
  "estimatedReadMinutes": 10,
  "activities": [
    {
      "type": "spark",
      "title": "The Double-Booking Problem",
      "desc": "Act out a hotel booking scenario with 2 clients booking the last room simultaneously. What goes wrong without locks? Brainstorm solutions first.",
      "time": "15 min",
      "format": "Group"
    },
    {
      "type": "intro",
      "title": "Fencing Token Diagram",
      "desc": "Draw the fencing token flow: client acquires lock, sends token, storage validates. Then show what happens when a stale client ignores the fence.",
      "time": "20 min",
      "format": "Solo"
    },
    {
      "type": "practice",
      "title": "Redlock Analysis",
      "desc": "Walk through Redis Redlock on N=5 nodes. Calculate: majority quorum, failure scenarios, and clock skew risks.",
      "time": "25 min",
      "format": "Group"
    },
    {
      "type": "assess",
      "title": "Lock Design Decision",
      "desc": "3 scenarios (payment deduction, seat reservation, leader election). Choose and justify the right locking strategy for each.",
      "time": "15 min",
      "format": "Solo"
    }
  ],
  "activityTypes": [
    "spark",
    "intro",
    "practice",
    "assess"
  ],
  "sections": {
    "concepts": [
      {
        "heading": "What it is",
        "body": "Distributed Locks & Coordination covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Lease-based locking, Quorum coordination, Fencing tokens and linking each concept to an architecture consequence."
      },
      {
        "heading": "Why it matters in interviews",
        "body": "Interviewers expect you to justify trade-offs, not just list tools. For Distributed Locks & Coordination, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
      }
    ],
    "architecture": {
      "components": [
        "Client",
        "API Gateway",
        "Core Service",
        "Cache",
        "Primary Database",
        "Message Queue",
        "Worker",
        "Monitoring"
      ],
      "flowSteps": [
        "Clarify scope and constraints for Distributed Locks & Coordination before choosing architecture primitives.",
        "Define boundaries for Lease-based locking and map request/write paths.",
        "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
        "Evaluate bottlenecks under peak load or feature expansion assumptions.",
        "Capture final trade-offs and explain why rejected alternatives were not selected."
      ],
      "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
    },
    "tradeoffs": [
      {
        "decision": "Consistency vs Availability",
        "optionA": "Strong consistency with synchronous coordination",
        "optionB": "Higher availability with eventual consistency",
        "chooseWhen": "Prefer option A for correctness-critical flows in Distributed Locks & Coordination; choose option B for read-heavy workloads with tolerant staleness.",
        "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
      },
      {
        "decision": "Latency vs Durability",
        "optionA": "Fast in-memory path with async persistence",
        "optionB": "Write-through path before ack",
        "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
        "risk": "Async persistence increases loss window; sync persistence increases tail latency."
      },
      {
        "decision": "Horizontal Scale vs Simplicity",
        "optionA": "Shard and partition early",
        "optionB": "Scale vertically and delay partitioning",
        "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
        "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
      },
      {
        "decision": "Operational Cost vs Performance",
        "optionA": "Multi-region active-active setup",
        "optionB": "Single region plus disaster recovery",
        "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
        "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
      }
    ],
    "examples": [
      {
        "name": "Seat Reservation",
        "context": "Seat Reservation demands clear boundaries around Lease-based locking and predictable behavior during peak usage.",
        "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
        "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
      },
      {
        "name": "Distributed Cron Leader",
        "context": "Distributed Cron Leader introduces changing requirements and forces design updates without breaking existing clients.",
        "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
        "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
      }
    ],
    "interviewQa": [
      {
        "question": "How would you design distributed locks & coordination for 10x growth?",
        "answerFramework": [
          "Clarify constraints and traffic shape",
          "Estimate scale and hotspots",
          "Propose baseline architecture",
          "Address bottlenecks and failure modes",
          "Explain final trade-offs"
        ]
      },
      {
        "question": "Which trade-off is most important in distributed locks & coordination and why?",
        "answerFramework": [
          "State competing goals",
          "Choose one based on business risk",
          "Describe mitigation for the rejected option",
          "Define monitoring signals",
          "Describe revisit trigger"
        ]
      },
      {
        "question": "How do you handle failures in Lease-based locking?",
        "answerFramework": [
          "Enumerate failure classes",
          "Add retries and idempotency boundaries",
          "Plan degraded behavior",
          "Protect data correctness",
          "Close with incident response approach"
        ]
      },
      {
        "question": "What would be your API and data model choices for distributed locks & coordination?",
        "answerFramework": [
          "List key entities",
          "Define read/write patterns",
          "Choose consistency level",
          "Define pagination or batching strategy",
          "Cover evolution and versioning"
        ]
      },
      {
        "question": "How would you explain this design to a senior interviewer in 5 minutes?",
        "answerFramework": [
          "Start with requirements",
          "Show architecture and data flow",
          "Highlight critical trade-offs",
          "Call out failure handling",
          "Suggest future improvements"
        ]
      }
    ],
    "revision": {
      "cheatSheet": [
        "Start every Distributed Locks & Coordination answer with assumptions and limits.",
        "Name one latency-sensitive path and one correctness-sensitive path.",
        "State how Lease-based locking is written and read under load.",
        "Explain one scaling strategy and one fallback strategy.",
        "Mention observability: metrics, logs, and tracing checkpoints.",
        "Call out a deliberate de-scope to keep MVP practical.",
        "Finish with what you would improve in version two."
      ],
      "redFlags": [
        "Choosing technology without linking it to constraints.",
        "Ignoring data consistency or idempotency for write operations.",
        "No failure-mode story for dependency outages.",
        "No plan to measure whether the design is actually working."
      ]
    }
  }
}
