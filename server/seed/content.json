{
  "generatedAt": "2026-02-22T13:20:22.673Z",
  "classIndex": [
    {
      "id": 1,
      "module": "sys",
      "slug": "system-design-foundations",
      "title": "System Design Foundations",
      "topics": [
        "CAP theorem",
        "Load estimation",
        "Caching",
        "REST API",
        "Fault tolerance"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "CAP Dilemma Debate",
          "desc": "Present 3 real systems (Amazon, Google Docs, Cassandra). Ask: which CAP properties do they sacrifice and why? Small groups debate, then share out.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Load Estimation Worksheet",
          "desc": "Give a scenario (e.g. a food delivery app). Students estimate RPS, bandwidth, and storage using back-of-envelope math. Walk through solution together.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Cache Strategy Card Sort",
          "desc": "Print cards describing scenarios. Students match each to read-through / write-through / write-back and justify the choice.",
          "time": "15 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "1-Minute Architecture Sketch",
          "desc": "Pose a simple system prompt (e.g. URL shortener). Students sketch a component diagram + API endpoints in 5 minutes, then peer-review.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 2,
      "module": "sys",
      "slug": "requirement-analysis-and-api-design",
      "title": "Requirement Analysis & API Design",
      "topics": [
        "Functional/non-functional",
        "REST",
        "Pagination",
        "SLA/SLO/SLI",
        "Redis/CDN"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Requirements Treasure Hunt",
          "desc": "Show a vague product brief ('Build a messaging app'). Students must extract hidden non-functional requirements buried in the description.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "API Contract Design",
          "desc": "Students design REST endpoints, pagination, and versioning for a given feature. Compare schemas and discuss trade-offs.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "SLO Definition Workshop",
          "desc": "Given a fintech app scenario, teams define SLOs for latency, availability, and error rate. Present and critique each other's targets.",
          "time": "25 min",
          "format": "Team"
        },
        {
          "type": "assess",
          "title": "Exit Quiz: NFRs",
          "desc": "5-question rapid quiz: identify whether each requirement is functional or non-functional. Includes tricky edge cases.",
          "time": "10 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 3,
      "module": "sys",
      "slug": "load-balancing-and-ci-cd-systems",
      "title": "Load Balancing & CI/CD Systems",
      "topics": [
        "L4 vs L7",
        "Nginx",
        "Job queues",
        "CI/CD pipelines",
        "Rollback"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Traffic Routing Simulation",
          "desc": "Use sticky notes on a whiteboard as 'requests'. Physically route them through L4 and L7 nodes. Visualize what gets dropped during a node failure.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "CI/CD Pipeline Flowchart",
          "desc": "Students draw a complete CI/CD pipeline from commit to production, labeling each stage, artifact store, and rollback trigger.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Rollback Scenario Drill",
          "desc": "Present a bad deploy scenario. Students must identify the rollback strategy, estimate blast radius, and write the incident checklist.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Nginx Config Review",
          "desc": "Share a simplified Nginx config with 2 bugs. Students spot, explain, and fix the issues.",
          "time": "10 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 4,
      "module": "sys",
      "slug": "database-architecture",
      "title": "Database Architecture",
      "topics": [
        "Read/write workloads",
        "Sharding",
        "Caching strategies",
        "Message delivery"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Read vs Write Heavy Challenge",
          "desc": "Show 4 real apps (Twitter, Bank, Netflix, WhatsApp). Classify each as read-heavy / write-heavy / both and explain the consequences.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Sharding Strategy Design",
          "desc": "Given a social media schema, students choose user-based vs region-based sharding, draw the shard map, and identify hotspot risks.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Cache Invalidation Puzzle",
          "desc": "Scenario: cached data goes stale. Students must trace the invalidation path and redesign the cache layer to prevent re-occurrence.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "DB Design Critique",
          "desc": "Show a flawed DB schema. Students write a short critique covering indexing, normalization, and scalability concerns.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 5,
      "module": "sys",
      "slug": "data-partitioning-and-consistency",
      "title": "Data Partitioning & Consistency",
      "topics": [
        "Consistent hashing",
        "Quorum",
        "Strong vs eventual",
        "Gossip protocol"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Consistent Hashing Ring Demo",
          "desc": "Use a physical ring (whiteboard circle) and sticky note 'nodes'. Add/remove nodes and see how keys redistribute. Count moves with/without virtual nodes.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Quorum Calculator",
          "desc": "Students calculate read quorum, write quorum, and fault tolerance for N=5, 7, 9 node clusters. Explore the R+W>N rule.",
          "time": "20 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Consistency Level Trade-off Table",
          "desc": "Create a 3-column table: scenario, recommended consistency level, justification. Fill in 6 real-world scenarios.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Gossip Protocol Trace",
          "desc": "Given a 6-node cluster with partial updates, trace how gossip spreads. Identify when all nodes converge.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 6,
      "module": "sys",
      "slug": "asynchronous-communication",
      "title": "Asynchronous Communication",
      "topics": [
        "Kafka",
        "Producer-consumer",
        "Topics/partitions",
        "Alert pipelines",
        "Monitoring"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Sync vs Async War Stories",
          "desc": "Start with a real outage story (e.g. a sync API cascade failure). Ask: how would async messaging have prevented this?",
          "time": "15 min",
          "format": "Discussion"
        },
        {
          "type": "intro",
          "title": "Kafka Architecture Diagram",
          "desc": "Students draw a Kafka setup from scratch: topics, partitions, producers, consumers, consumer groups, and offsets for an e-commerce order system.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Message Ordering Challenge",
          "desc": "Scenario: an order system needs strict message ordering per user but high parallelism overall. Students design the partition key strategy.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Alert Pipeline Design",
          "desc": "Design an alert pipeline from metrics ingestion to notification. Must specify queue, processing, deduplication, and delivery stages.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 7,
      "module": "sys",
      "slug": "search-and-indexing-systems",
      "title": "Search & Indexing Systems",
      "topics": [
        "Data ingestion",
        "Tokenization",
        "Index maintenance",
        "Ranking",
        "Query optimization"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Google Search Reverse-Engineering",
          "desc": "Search for the same query 3 different ways. Compare results. Hypothesize: what signals might influence the ranking?",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Inverted Index Builder",
          "desc": "Manually build an inverted index for 5 short documents. Perform a multi-term query and trace the lookup path.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Query Optimization Lab",
          "desc": "Given a slow search query plan, students rewrite it using filter-first, scoring optimization, and caching strategies.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Architecture Review: E-commerce Search",
          "desc": "Sketch a full search system for an e-commerce site covering ingest, index, query, and cache layers.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 8,
      "module": "sys",
      "slug": "distributed-storage",
      "title": "Distributed Storage",
      "topics": [
        "Object storage",
        "Chunking",
        "Deduplication",
        "Versioning",
        "Cross-region sync"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "How Dropbox Works? Guess It!",
          "desc": "Before the lesson, students sketch how they think Dropbox stores files. After the lesson, compare original sketch with real architecture.",
          "time": "20 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "Chunking & Dedup Exercise",
          "desc": "Given 3 files with overlapping content, manually apply content-addressed chunking and calculate storage savings from deduplication.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Multi-Region Sync Design",
          "desc": "Design cross-region sync for a file storage system: handle conflict resolution, bandwidth cost, and consistency.",
          "time": "25 min",
          "format": "Teams"
        },
        {
          "type": "assess",
          "title": "Metadata DB Schema",
          "desc": "Design a metadata DB for a cloud storage system covering file versioning, chunk references, and access control.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 9,
      "module": "sys",
      "slug": "domain-name-resolution",
      "title": "Domain Name Resolution",
      "topics": [
        "DNS resolution",
        "Recursive/iterative queries",
        "TTL",
        "DNS load balancing"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "DNS Detective",
          "desc": "Run `nslookup` on 5 different popular domains. Compare TTLs, IP counts, and response types. What patterns do you notice?",
          "time": "15 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "DNS Resolution Walkthrough",
          "desc": "Physically act out a DNS resolution: one student is the browser, others are resolver, root, TLD, and authoritative servers. Pass paper 'queries' between roles.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "practice",
          "title": "TTL Trade-off Analysis",
          "desc": "Given 3 scenarios (marketing site, banking API, streaming CDN), choose the ideal TTL and justify: cache freshness vs resolver load.",
          "time": "15 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "DNS Load Balancing Plan",
          "desc": "Design a DNS-based load balancing strategy for a global app with users in 3 regions. Cover geo-routing, health checks, and failover.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 10,
      "module": "sys",
      "slug": "distributed-locks-and-coordination",
      "title": "Distributed Locks & Coordination",
      "topics": [
        "Lease-based locking",
        "Quorum coordination",
        "Fencing tokens",
        "Consensus"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "The Double-Booking Problem",
          "desc": "Act out a hotel booking scenario with 2 clients booking the last room simultaneously. What goes wrong without locks? Brainstorm solutions first.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Fencing Token Diagram",
          "desc": "Draw the fencing token flow: client acquires lock, sends token, storage validates. Then show what happens when a stale client ignores the fence.",
          "time": "20 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Redlock Analysis",
          "desc": "Walk through Redis Redlock on N=5 nodes. Calculate: majority quorum, failure scenarios, and clock skew risks.",
          "time": "25 min",
          "format": "Group"
        },
        {
          "type": "assess",
          "title": "Lock Design Decision",
          "desc": "3 scenarios (payment deduction, seat reservation, leader election). Choose and justify the right locking strategy for each.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 11,
      "module": "sys",
      "slug": "distributed-transactions-and-consensus",
      "title": "Distributed Transactions & Consensus",
      "topics": [
        "2PC",
        "Rollback/compensation",
        "Idempotency",
        "WAL",
        "Failure recovery"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Bank Transfer Gone Wrong",
          "desc": "Simulate a money transfer where the debit succeeds but credit fails. Walk through the disaster and ask: what should have happened?",
          "time": "15 min",
          "format": "Discussion"
        },
        {
          "type": "intro",
          "title": "2PC Phase Diagram",
          "desc": "Students draw the 2PC protocol with coordinator + 2 participants, labeling prepare, commit, abort, and failure paths.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Idempotency Key Design",
          "desc": "Design idempotency for a payment API: define the key structure, storage, expiry, and duplicate detection logic.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Saga vs 2PC Comparison",
          "desc": "Given 2 scenarios, students choose between Saga and 2PC, and write a 1-paragraph justification for each.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 12,
      "module": "sys",
      "slug": "peer-to-peer-systems",
      "title": "Peer-to-Peer Systems",
      "topics": [
        "Peer discovery",
        "DHT",
        "Data routing",
        "Fault tolerance",
        "Chunk replication"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "BitTorrent In The Room",
          "desc": "Simulate a file share using sticky note 'chunks'. Students must find peers, request chunks, and reassemble the file. Feel how P2P works.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "DHT Key Lookup",
          "desc": "Build a simple Kademlia-style DHT on paper: place nodes on a keyspace, route a lookup step-by-step using XOR distance.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Churn Simulation",
          "desc": "Given a 10-node P2P network, randomly remove 3 nodes. Show how the system re-routes, replicates, and heals.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "assess",
          "title": "P2P Design Brief",
          "desc": "Design a P2P video streaming network. Cover discovery, chunk distribution, NAT traversal, and abuse prevention.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 13,
      "module": "lld",
      "slug": "oop-principles-and-uml-basics",
      "title": "OOP Principles & UML Basics",
      "topics": [
        "Encapsulation",
        "Inheritance",
        "Polymorphism",
        "UML class & sequence diagrams"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Real-World Object Hunt",
          "desc": "Pick 3 objects from your daily life. Model them as classes with attributes, methods, and relationships. Which OOP principle does each embody?",
          "time": "15 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "UML Class Diagram: Library System",
          "desc": "Students draw a complete UML class diagram for a library: Book, Member, Loan — with multiplicity, access modifiers, and relationships.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Sequence Diagram Trace",
          "desc": "Trace the sequence of a user checking out a book: draw lifelines, messages, and return arrows for all participants.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Aggregation vs Composition Quiz",
          "desc": "10 relationship examples. Students label each as aggregation, composition, association, or inheritance with a one-line reason.",
          "time": "10 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 14,
      "module": "lld",
      "slug": "design-patterns-creational",
      "title": "Design Patterns: Creational",
      "topics": [
        "Factory",
        "Abstract Factory",
        "Singleton",
        "Builder",
        "Object creation decoupling"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Pattern Scavenger Hunt",
          "desc": "Open any popular open-source library. Find and name at least 2 creational patterns used in the codebase. Share findings.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Builder vs Constructor Comparison",
          "desc": "Implement a Pizza class: first with a telescoping constructor, then with Builder. Count parameters and compare readability.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Singleton Anti-pattern Lab",
          "desc": "Given a broken Singleton with thread-safety issues, students identify the race condition and fix it using double-checked locking.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Pattern Identification MCQ",
          "desc": "6 code snippets — identify which creational pattern each uses and what problem it solves.",
          "time": "10 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 15,
      "module": "lld",
      "slug": "solid-principles",
      "title": "SOLID Principles",
      "topics": [
        "SRP",
        "OCP",
        "LSP",
        "ISP",
        "DIP",
        "Code smells",
        "Cohesion/coupling"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Code Smell Gallery Walk",
          "desc": "Post 5 code snippets around the room (or screen). Students rotate and annotate each with the SOLID principle being violated.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Refactor to SOLID",
          "desc": "Give a bloated God class. Students refactor it step-by-step: extract responsibilities, invert dependencies, and segregate interfaces.",
          "time": "35 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "LSP Litmus Test",
          "desc": "Show 5 inheritance hierarchies. Students apply the Liskov test: 'Can I replace the parent with this child without breaking behavior?'",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Design Review Memo",
          "desc": "Provide a 50-line class. Students write a short review identifying SOLID violations and proposing fixes.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 16,
      "module": "lld",
      "slug": "structural-patterns",
      "title": "Structural Patterns",
      "topics": [
        "Adapter",
        "Facade",
        "Composite",
        "Decorator",
        "Composition over inheritance"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Real-World Pattern Mapping",
          "desc": "Match each structural pattern to a real-world analog: Adapter = power plug converter, Facade = car dashboard... Students come up with their own.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Decorator Chain Builder",
          "desc": "Build a text formatter: plain → bold → italic → underline using the Decorator pattern. Show how decorators stack without modifying originals.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Adapter Design Challenge",
          "desc": "Given a legacy payment API and a new interface contract, design an Adapter that bridges them. Map each method and handle mismatches.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Pattern Selection Justification",
          "desc": "3 scenarios. Students choose the correct structural pattern and write a 2-sentence justification for each choice.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 17,
      "module": "lld",
      "slug": "behavioral-patterns-i",
      "title": "Behavioral Patterns I",
      "topics": [
        "Strategy",
        "Observer",
        "Command",
        "Event-driven interactions"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Strategy vs Hard-coding",
          "desc": "Show a sorting function with 4 if/else branches. Refactor live into Strategy. Count how many lines changed — and how many didn't.",
          "time": "20 min",
          "format": "Demo"
        },
        {
          "type": "intro",
          "title": "Observer Pattern Simulation",
          "desc": "Students model a notification system: one 'publisher' posts events, multiple 'subscribers' react differently. Draw the event flow and observer registration.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Command + Undo Implementation",
          "desc": "Design a text editor's undo/redo using Command pattern. Implement execute(), undo(), and a command history stack.",
          "time": "25 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Pattern Refactoring Task",
          "desc": "Given monolithic event handling code, refactor it using Observer or Command with a brief explanation of the design decision.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 18,
      "module": "lld",
      "slug": "behavioral-patterns-ii",
      "title": "Behavioral Patterns II",
      "topics": [
        "State",
        "Chain of Responsibility",
        "Workflow handling",
        "Transaction modeling"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "State Machine Exploration",
          "desc": "Map out the states of a vending machine or traffic light on a whiteboard. Students discover they've drawn a State pattern without being told.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "State Transition Diagram",
          "desc": "Design a full State Machine for an order lifecycle: pending → confirmed → shipped → delivered → returned, with allowed transitions.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Chain of Responsibility Design",
          "desc": "Design a support ticket escalation: L1 → L2 → Manager → CEO. Implement handler chaining, early exit, and fallback.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Transaction Flow Modeling",
          "desc": "Model a payment transaction state machine with success, failure, retry, and timeout states. Include transitions and guard conditions.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 19,
      "module": "lld",
      "slug": "concurrency-in-lld",
      "title": "Concurrency in LLD",
      "topics": [
        "Mutex",
        "Semaphore",
        "Thread pools",
        "Deadlock",
        "Safe resource access"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Dining Philosophers Live",
          "desc": "5 students, 5 pencils, 5 plates of 'food'. Simulate the Dining Philosophers problem. Who deadlocks first? Then find the fix.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Mutex vs Semaphore Showdown",
          "desc": "Design 2 scenarios: one needs mutual exclusion, one needs resource counting. Implement both and explain why each choice is correct.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Thread Pool Sizing Calculator",
          "desc": "Given CPU-bound vs I/O-bound workloads, calculate optimal thread pool size using Little's Law and benchmark assumptions.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Deadlock Detection Drill",
          "desc": "Show 3 code snippets with concurrent resource acquisition. Identify which causes a deadlock and rewrite to fix it.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 20,
      "module": "lld",
      "slug": "extensible-system-design",
      "title": "Extensible System Design",
      "topics": [
        "Polymorphism",
        "Strategy-based rules",
        "Domain modeling",
        "Feature extensibility"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Feature Request Chaos",
          "desc": "Start with a simple discount calculator. Add 5 new requirements one by one. Watch the code collapse without extensibility. Then redesign.",
          "time": "20 min",
          "format": "Demo"
        },
        {
          "type": "intro",
          "title": "Polymorphic Discount Engine",
          "desc": "Design a discount system using polymorphism: PercentageDiscount, FixedDiscount, BuyOneGetOne. Add a new type without touching existing code.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Board Game Domain Model",
          "desc": "Model a board game engine (Chess or Checkers): pieces, moves, validation rules — designed for extensibility to new game types.",
          "time": "30 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Extensibility Checklist Review",
          "desc": "Review a provided design. Score it on: OCP compliance, polymorphism use, coupling level, ease of adding features. Give a 1-5 score with justification.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 21,
      "module": "lld",
      "slug": "persistence-and-repositories",
      "title": "Persistence & Repositories",
      "topics": [
        "Entity modeling",
        "Relationship mapping",
        "Transactions",
        "Repository pattern",
        "Service layer"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "ORM vs Raw SQL Debate",
          "desc": "Show the same query in ORM and raw SQL. Discuss: when does each shine? Where does ORM abstraction break down?",
          "time": "15 min",
          "format": "Discussion"
        },
        {
          "type": "intro",
          "title": "Repository Pattern Implementation",
          "desc": "Implement UserRepository with CRUD methods behind an interface. Show how the service layer never touches the DB directly.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Transaction Boundary Design",
          "desc": "Given a multi-step order creation flow (create order + deduct stock + charge payment), define transaction boundaries and rollback logic.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Layered Architecture Review",
          "desc": "Diagram a feature request end-to-end: Controller → Service → Repository → DB. Identify any layer violations or leaky abstractions.",
          "time": "15 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 22,
      "module": "lld",
      "slug": "api-layer-and-error-handling",
      "title": "API Layer & Error Handling",
      "topics": [
        "REST endpoints",
        "Input validation",
        "Rate limiting",
        "HTTP codes",
        "Global error handling"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "HTTP Status Code Roulette",
          "desc": "Call 10 real public APIs with bad inputs. Log the status codes returned. Vote on which ones are correct, misleading, or lazy.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Error Handling Framework Design",
          "desc": "Design a global error handler: map exceptions to HTTP codes, define error response schema, and handle validation vs business vs infra errors differently.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Rate Limiting Algorithm Comparison",
          "desc": "Implement token bucket and leaky bucket on paper for the same traffic pattern. Compare burst behavior and smoothness.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "API Design Audit",
          "desc": "Review a provided REST API spec. Identify: missing validation, wrong status codes, unclear error messages, and security gaps.",
          "time": "20 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 23,
      "module": "lld",
      "slug": "code-review-and-refactoring",
      "title": "Code Review & Refactoring",
      "topics": [
        "Design problems",
        "Modularization",
        "Naming conventions",
        "Readability",
        "Separation of concerns"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "WTF/Minute Code Review",
          "desc": "Display notoriously messy code. Students count their 'WTFs per minute' as a humorous proxy for code quality. Then identify fixes.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Refactoring Kata",
          "desc": "Give a working but messy function (e.g. a billing calculator). Students refactor it in stages: rename → extract → split → test-name → simplify.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Peer Code Review Round",
          "desc": "Exchange code snippets with a partner. Write a structured code review covering: naming, cohesion, complexity, and testability.",
          "time": "25 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Before/After Explanation",
          "desc": "Show a before and after refactoring. Students write a paragraph explaining what changed, why it's better, and what trade-offs were made.",
          "time": "10 min",
          "format": "Solo"
        }
      ]
    },
    {
      "id": 24,
      "module": "lld",
      "slug": "capstone-lld-mock-interview",
      "title": "Capstone: LLD Mock Interview",
      "topics": [
        "End-to-end LLD",
        "OOP modeling",
        "Persistence",
        "Trade-offs",
        "Scalability"
      ],
      "estimatedReadMinutes": 10,
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "activities": [
        {
          "type": "spark",
          "title": "Warm-Up: 5-Min Sketch",
          "desc": "Give a simple problem (Parking Lot or ATM). 5 minutes, draw anything. No pressure — just get ideas on paper. Share and compare approaches.",
          "time": "10 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "Structured Problem-Solving Framework",
          "desc": "Walk through the 5-step LLD interview approach: clarify → identify entities → design classes → add patterns → discuss trade-offs.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "practice",
          "title": "Full Mock Interview: 35 Min Design",
          "desc": "Choose one: Hotel Reservation, Ride Sharing, or Movie Booking. Design the full system: OOP model, persistence, API layer, and scalability notes.",
          "time": "35 min",
          "format": "Solo"
        },
        {
          "type": "assess",
          "title": "Design Presentation & Peer Critique",
          "desc": "Each student presents their capstone design for 5 minutes. Peers give structured feedback: 1 strength, 1 improvement, 1 question.",
          "time": "30 min",
          "format": "Group"
        }
      ]
    }
  ],
  "classes": [
    {
      "id": 1,
      "module": "sys",
      "slug": "system-design-foundations",
      "title": "System Design Foundations",
      "topics": [
        "CAP theorem",
        "Load estimation",
        "Caching",
        "REST API",
        "Fault tolerance"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "CAP Dilemma Debate",
          "desc": "Present 3 real systems (Amazon, Google Docs, Cassandra). Ask: which CAP properties do they sacrifice and why? Small groups debate, then share out.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Load Estimation Worksheet",
          "desc": "Give a scenario (e.g. a food delivery app). Students estimate RPS, bandwidth, and storage using back-of-envelope math. Walk through solution together.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Cache Strategy Card Sort",
          "desc": "Print cards describing scenarios. Students match each to read-through / write-through / write-back and justify the choice.",
          "time": "15 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "1-Minute Architecture Sketch",
          "desc": "Pose a simple system prompt (e.g. URL shortener). Students sketch a component diagram + API endpoints in 5 minutes, then peer-review.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "System Design Foundations covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding CAP theorem, Load estimation, Caching and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For System Design Foundations, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for System Design Foundations before choosing architecture primitives.",
            "Define boundaries for CAP theorem and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in System Design Foundations; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "URL Shortener",
            "context": "URL Shortener demands clear boundaries around CAP theorem and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Food Delivery Dispatch",
            "context": "Food Delivery Dispatch introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design system design foundations for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in system design foundations and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in CAP theorem?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for system design foundations?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every System Design Foundations answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how CAP theorem is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 2,
      "module": "sys",
      "slug": "requirement-analysis-and-api-design",
      "title": "Requirement Analysis & API Design",
      "topics": [
        "Functional/non-functional",
        "REST",
        "Pagination",
        "SLA/SLO/SLI",
        "Redis/CDN"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Requirements Treasure Hunt",
          "desc": "Show a vague product brief ('Build a messaging app'). Students must extract hidden non-functional requirements buried in the description.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "API Contract Design",
          "desc": "Students design REST endpoints, pagination, and versioning for a given feature. Compare schemas and discuss trade-offs.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "SLO Definition Workshop",
          "desc": "Given a fintech app scenario, teams define SLOs for latency, availability, and error rate. Present and critique each other's targets.",
          "time": "25 min",
          "format": "Team"
        },
        {
          "type": "assess",
          "title": "Exit Quiz: NFRs",
          "desc": "5-question rapid quiz: identify whether each requirement is functional or non-functional. Includes tricky edge cases.",
          "time": "10 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Requirement Analysis & API Design covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Functional/non-functional, REST, Pagination and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Requirement Analysis & API Design, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Requirement Analysis & API Design before choosing architecture primitives.",
            "Define boundaries for Functional/non-functional and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Requirement Analysis & API Design; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Messaging API",
            "context": "Messaging API demands clear boundaries around Functional/non-functional and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Fintech Account Service",
            "context": "Fintech Account Service introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design requirement analysis & api design for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in requirement analysis & api design and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Functional/non-functional?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for requirement analysis & api design?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Requirement Analysis & API Design answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Functional/non-functional is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 3,
      "module": "sys",
      "slug": "load-balancing-and-ci-cd-systems",
      "title": "Load Balancing & CI/CD Systems",
      "topics": [
        "L4 vs L7",
        "Nginx",
        "Job queues",
        "CI/CD pipelines",
        "Rollback"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Traffic Routing Simulation",
          "desc": "Use sticky notes on a whiteboard as 'requests'. Physically route them through L4 and L7 nodes. Visualize what gets dropped during a node failure.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "CI/CD Pipeline Flowchart",
          "desc": "Students draw a complete CI/CD pipeline from commit to production, labeling each stage, artifact store, and rollback trigger.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Rollback Scenario Drill",
          "desc": "Present a bad deploy scenario. Students must identify the rollback strategy, estimate blast radius, and write the incident checklist.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Nginx Config Review",
          "desc": "Share a simplified Nginx config with 2 bugs. Students spot, explain, and fix the issues.",
          "time": "10 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Load Balancing & CI/CD Systems covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding L4 vs L7, Nginx, Job queues and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Load Balancing & CI/CD Systems, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Load Balancing & CI/CD Systems before choosing architecture primitives.",
            "Define boundaries for L4 vs L7 and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Load Balancing & CI/CD Systems; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Checkout Service Deployment",
            "context": "Checkout Service Deployment demands clear boundaries around L4 vs L7 and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "ML Inference Rollout",
            "context": "ML Inference Rollout introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design load balancing & ci/cd systems for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in load balancing & ci/cd systems and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in L4 vs L7?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for load balancing & ci/cd systems?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Load Balancing & CI/CD Systems answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how L4 vs L7 is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 4,
      "module": "sys",
      "slug": "database-architecture",
      "title": "Database Architecture",
      "topics": [
        "Read/write workloads",
        "Sharding",
        "Caching strategies",
        "Message delivery"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Read vs Write Heavy Challenge",
          "desc": "Show 4 real apps (Twitter, Bank, Netflix, WhatsApp). Classify each as read-heavy / write-heavy / both and explain the consequences.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Sharding Strategy Design",
          "desc": "Given a social media schema, students choose user-based vs region-based sharding, draw the shard map, and identify hotspot risks.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Cache Invalidation Puzzle",
          "desc": "Scenario: cached data goes stale. Students must trace the invalidation path and redesign the cache layer to prevent re-occurrence.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "DB Design Critique",
          "desc": "Show a flawed DB schema. Students write a short critique covering indexing, normalization, and scalability concerns.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Database Architecture covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Read/write workloads, Sharding, Caching strategies and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Database Architecture, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Database Architecture before choosing architecture primitives.",
            "Define boundaries for Read/write workloads and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Database Architecture; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Social Feed Storage",
            "context": "Social Feed Storage demands clear boundaries around Read/write workloads and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Payment Ledger Storage",
            "context": "Payment Ledger Storage introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design database architecture for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in database architecture and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Read/write workloads?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for database architecture?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Database Architecture answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Read/write workloads is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 5,
      "module": "sys",
      "slug": "data-partitioning-and-consistency",
      "title": "Data Partitioning & Consistency",
      "topics": [
        "Consistent hashing",
        "Quorum",
        "Strong vs eventual",
        "Gossip protocol"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Consistent Hashing Ring Demo",
          "desc": "Use a physical ring (whiteboard circle) and sticky note 'nodes'. Add/remove nodes and see how keys redistribute. Count moves with/without virtual nodes.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Quorum Calculator",
          "desc": "Students calculate read quorum, write quorum, and fault tolerance for N=5, 7, 9 node clusters. Explore the R+W>N rule.",
          "time": "20 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Consistency Level Trade-off Table",
          "desc": "Create a 3-column table: scenario, recommended consistency level, justification. Fill in 6 real-world scenarios.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Gossip Protocol Trace",
          "desc": "Given a 6-node cluster with partial updates, trace how gossip spreads. Identify when all nodes converge.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Data Partitioning & Consistency covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Consistent hashing, Quorum, Strong vs eventual and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Data Partitioning & Consistency, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Data Partitioning & Consistency before choosing architecture primitives.",
            "Define boundaries for Consistent hashing and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Data Partitioning & Consistency; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Shopping Cart Replication",
            "context": "Shopping Cart Replication demands clear boundaries around Consistent hashing and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "User Profile Sync",
            "context": "User Profile Sync introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design data partitioning & consistency for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in data partitioning & consistency and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Consistent hashing?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for data partitioning & consistency?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Data Partitioning & Consistency answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Consistent hashing is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 6,
      "module": "sys",
      "slug": "asynchronous-communication",
      "title": "Asynchronous Communication",
      "topics": [
        "Kafka",
        "Producer-consumer",
        "Topics/partitions",
        "Alert pipelines",
        "Monitoring"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Sync vs Async War Stories",
          "desc": "Start with a real outage story (e.g. a sync API cascade failure). Ask: how would async messaging have prevented this?",
          "time": "15 min",
          "format": "Discussion"
        },
        {
          "type": "intro",
          "title": "Kafka Architecture Diagram",
          "desc": "Students draw a Kafka setup from scratch: topics, partitions, producers, consumers, consumer groups, and offsets for an e-commerce order system.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Message Ordering Challenge",
          "desc": "Scenario: an order system needs strict message ordering per user but high parallelism overall. Students design the partition key strategy.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Alert Pipeline Design",
          "desc": "Design an alert pipeline from metrics ingestion to notification. Must specify queue, processing, deduplication, and delivery stages.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Asynchronous Communication covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Kafka, Producer-consumer, Topics/partitions and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Asynchronous Communication, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Asynchronous Communication before choosing architecture primitives.",
            "Define boundaries for Kafka and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Asynchronous Communication; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Order Event Pipeline",
            "context": "Order Event Pipeline demands clear boundaries around Kafka and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Fraud Alert Stream",
            "context": "Fraud Alert Stream introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design asynchronous communication for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in asynchronous communication and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Kafka?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for asynchronous communication?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Asynchronous Communication answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Kafka is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 7,
      "module": "sys",
      "slug": "search-and-indexing-systems",
      "title": "Search & Indexing Systems",
      "topics": [
        "Data ingestion",
        "Tokenization",
        "Index maintenance",
        "Ranking",
        "Query optimization"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Google Search Reverse-Engineering",
          "desc": "Search for the same query 3 different ways. Compare results. Hypothesize: what signals might influence the ranking?",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Inverted Index Builder",
          "desc": "Manually build an inverted index for 5 short documents. Perform a multi-term query and trace the lookup path.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Query Optimization Lab",
          "desc": "Given a slow search query plan, students rewrite it using filter-first, scoring optimization, and caching strategies.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Architecture Review: E-commerce Search",
          "desc": "Sketch a full search system for an e-commerce site covering ingest, index, query, and cache layers.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Search & Indexing Systems covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Data ingestion, Tokenization, Index maintenance and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Search & Indexing Systems, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Search & Indexing Systems before choosing architecture primitives.",
            "Define boundaries for Data ingestion and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Search & Indexing Systems; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Product Search",
            "context": "Product Search demands clear boundaries around Data ingestion and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Support Ticket Search",
            "context": "Support Ticket Search introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design search & indexing systems for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in search & indexing systems and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Data ingestion?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for search & indexing systems?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Search & Indexing Systems answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Data ingestion is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 8,
      "module": "sys",
      "slug": "distributed-storage",
      "title": "Distributed Storage",
      "topics": [
        "Object storage",
        "Chunking",
        "Deduplication",
        "Versioning",
        "Cross-region sync"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "How Dropbox Works? Guess It!",
          "desc": "Before the lesson, students sketch how they think Dropbox stores files. After the lesson, compare original sketch with real architecture.",
          "time": "20 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "Chunking & Dedup Exercise",
          "desc": "Given 3 files with overlapping content, manually apply content-addressed chunking and calculate storage savings from deduplication.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Multi-Region Sync Design",
          "desc": "Design cross-region sync for a file storage system: handle conflict resolution, bandwidth cost, and consistency.",
          "time": "25 min",
          "format": "Teams"
        },
        {
          "type": "assess",
          "title": "Metadata DB Schema",
          "desc": "Design a metadata DB for a cloud storage system covering file versioning, chunk references, and access control.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Distributed Storage covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Object storage, Chunking, Deduplication and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Distributed Storage, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Distributed Storage before choosing architecture primitives.",
            "Define boundaries for Object storage and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Distributed Storage; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Cloud Drive",
            "context": "Cloud Drive demands clear boundaries around Object storage and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Media Backup",
            "context": "Media Backup introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design distributed storage for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in distributed storage and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Object storage?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for distributed storage?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Distributed Storage answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Object storage is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 9,
      "module": "sys",
      "slug": "domain-name-resolution",
      "title": "Domain Name Resolution",
      "topics": [
        "DNS resolution",
        "Recursive/iterative queries",
        "TTL",
        "DNS load balancing"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "DNS Detective",
          "desc": "Run `nslookup` on 5 different popular domains. Compare TTLs, IP counts, and response types. What patterns do you notice?",
          "time": "15 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "DNS Resolution Walkthrough",
          "desc": "Physically act out a DNS resolution: one student is the browser, others are resolver, root, TLD, and authoritative servers. Pass paper 'queries' between roles.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "practice",
          "title": "TTL Trade-off Analysis",
          "desc": "Given 3 scenarios (marketing site, banking API, streaming CDN), choose the ideal TTL and justify: cache freshness vs resolver load.",
          "time": "15 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "DNS Load Balancing Plan",
          "desc": "Design a DNS-based load balancing strategy for a global app with users in 3 regions. Cover geo-routing, health checks, and failover.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Domain Name Resolution covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding DNS resolution, Recursive/iterative queries, TTL and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Domain Name Resolution, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Domain Name Resolution before choosing architecture primitives.",
            "Define boundaries for DNS resolution and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Domain Name Resolution; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Global Web App",
            "context": "Global Web App demands clear boundaries around DNS resolution and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "API Failover Domain",
            "context": "API Failover Domain introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design domain name resolution for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in domain name resolution and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in DNS resolution?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for domain name resolution?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Domain Name Resolution answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how DNS resolution is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 10,
      "module": "sys",
      "slug": "distributed-locks-and-coordination",
      "title": "Distributed Locks & Coordination",
      "topics": [
        "Lease-based locking",
        "Quorum coordination",
        "Fencing tokens",
        "Consensus"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "The Double-Booking Problem",
          "desc": "Act out a hotel booking scenario with 2 clients booking the last room simultaneously. What goes wrong without locks? Brainstorm solutions first.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Fencing Token Diagram",
          "desc": "Draw the fencing token flow: client acquires lock, sends token, storage validates. Then show what happens when a stale client ignores the fence.",
          "time": "20 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Redlock Analysis",
          "desc": "Walk through Redis Redlock on N=5 nodes. Calculate: majority quorum, failure scenarios, and clock skew risks.",
          "time": "25 min",
          "format": "Group"
        },
        {
          "type": "assess",
          "title": "Lock Design Decision",
          "desc": "3 scenarios (payment deduction, seat reservation, leader election). Choose and justify the right locking strategy for each.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Distributed Locks & Coordination covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Lease-based locking, Quorum coordination, Fencing tokens and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Distributed Locks & Coordination, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Distributed Locks & Coordination before choosing architecture primitives.",
            "Define boundaries for Lease-based locking and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Distributed Locks & Coordination; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Seat Reservation",
            "context": "Seat Reservation demands clear boundaries around Lease-based locking and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Distributed Cron Leader",
            "context": "Distributed Cron Leader introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design distributed locks & coordination for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in distributed locks & coordination and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Lease-based locking?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for distributed locks & coordination?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Distributed Locks & Coordination answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Lease-based locking is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 11,
      "module": "sys",
      "slug": "distributed-transactions-and-consensus",
      "title": "Distributed Transactions & Consensus",
      "topics": [
        "2PC",
        "Rollback/compensation",
        "Idempotency",
        "WAL",
        "Failure recovery"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Bank Transfer Gone Wrong",
          "desc": "Simulate a money transfer where the debit succeeds but credit fails. Walk through the disaster and ask: what should have happened?",
          "time": "15 min",
          "format": "Discussion"
        },
        {
          "type": "intro",
          "title": "2PC Phase Diagram",
          "desc": "Students draw the 2PC protocol with coordinator + 2 participants, labeling prepare, commit, abort, and failure paths.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Idempotency Key Design",
          "desc": "Design idempotency for a payment API: define the key structure, storage, expiry, and duplicate detection logic.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Saga vs 2PC Comparison",
          "desc": "Given 2 scenarios, students choose between Saga and 2PC, and write a 1-paragraph justification for each.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Distributed Transactions & Consensus covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding 2PC, Rollback/compensation, Idempotency and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Distributed Transactions & Consensus, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Distributed Transactions & Consensus before choosing architecture primitives.",
            "Define boundaries for 2PC and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Distributed Transactions & Consensus; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "Wallet Transfer",
            "context": "Wallet Transfer demands clear boundaries around 2PC and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Order Compensation Flow",
            "context": "Order Compensation Flow introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design distributed transactions & consensus for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in distributed transactions & consensus and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in 2PC?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for distributed transactions & consensus?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Distributed Transactions & Consensus answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how 2PC is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 12,
      "module": "sys",
      "slug": "peer-to-peer-systems",
      "title": "Peer-to-Peer Systems",
      "topics": [
        "Peer discovery",
        "DHT",
        "Data routing",
        "Fault tolerance",
        "Chunk replication"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "BitTorrent In The Room",
          "desc": "Simulate a file share using sticky note 'chunks'. Students must find peers, request chunks, and reassemble the file. Feel how P2P works.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "DHT Key Lookup",
          "desc": "Build a simple Kademlia-style DHT on paper: place nodes on a keyspace, route a lookup step-by-step using XOR distance.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Churn Simulation",
          "desc": "Given a 10-node P2P network, randomly remove 3 nodes. Show how the system re-routes, replicates, and heals.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "assess",
          "title": "P2P Design Brief",
          "desc": "Design a P2P video streaming network. Cover discovery, chunk distribution, NAT traversal, and abuse prevention.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Peer-to-Peer Systems covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Peer discovery, DHT, Data routing and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Peer-to-Peer Systems, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "Client",
            "API Gateway",
            "Core Service",
            "Cache",
            "Primary Database",
            "Message Queue",
            "Worker",
            "Monitoring"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Peer-to-Peer Systems before choosing architecture primitives.",
            "Define boundaries for Peer discovery and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Gateway --> Service Layer --> Cache\n                              |            |\n                              v            v\n                        Message Queue --> Workers\n                              |\n                              v\n                         Primary Database\n                              |\n                              v\n                           Monitoring"
        },
        "tradeoffs": [
          {
            "decision": "Consistency vs Availability",
            "optionA": "Strong consistency with synchronous coordination",
            "optionB": "Higher availability with eventual consistency",
            "chooseWhen": "Prefer option A for correctness-critical flows in Peer-to-Peer Systems; choose option B for read-heavy workloads with tolerant staleness.",
            "risk": "Choosing incorrectly can either over-complicate the stack or produce stale data under failures."
          },
          {
            "decision": "Latency vs Durability",
            "optionA": "Fast in-memory path with async persistence",
            "optionB": "Write-through path before ack",
            "chooseWhen": "Use fast path when user experience and throughput dominate; use durable path for financial or irreversible operations.",
            "risk": "Async persistence increases loss window; sync persistence increases tail latency."
          },
          {
            "decision": "Horizontal Scale vs Simplicity",
            "optionA": "Shard and partition early",
            "optionB": "Scale vertically and delay partitioning",
            "chooseWhen": "Adopt sharding when clear data volume growth exists; stay simple when traffic is modest and team size is small.",
            "risk": "Premature sharding raises ops burden; delaying too long can cause painful migrations."
          },
          {
            "decision": "Operational Cost vs Performance",
            "optionA": "Multi-region active-active setup",
            "optionB": "Single region plus disaster recovery",
            "chooseWhen": "Choose multi-region for strict global SLA and low-latency demands; choose single region to control cost and complexity.",
            "risk": "Multi-region introduces replication and consistency challenges; single-region increases outage blast radius."
          }
        ],
        "examples": [
          {
            "name": "P2P Content Distribution",
            "context": "P2P Content Distribution demands clear boundaries around Peer discovery and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Live Stream Mesh",
            "context": "Live Stream Mesh introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design peer-to-peer systems for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in peer-to-peer systems and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Peer discovery?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for peer-to-peer systems?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Peer-to-Peer Systems answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Peer discovery is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 13,
      "module": "lld",
      "slug": "oop-principles-and-uml-basics",
      "title": "OOP Principles & UML Basics",
      "topics": [
        "Encapsulation",
        "Inheritance",
        "Polymorphism",
        "UML class & sequence diagrams"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Real-World Object Hunt",
          "desc": "Pick 3 objects from your daily life. Model them as classes with attributes, methods, and relationships. Which OOP principle does each embody?",
          "time": "15 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "UML Class Diagram: Library System",
          "desc": "Students draw a complete UML class diagram for a library: Book, Member, Loan — with multiplicity, access modifiers, and relationships.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Sequence Diagram Trace",
          "desc": "Trace the sequence of a user checking out a book: draw lifelines, messages, and return arrows for all participants.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Aggregation vs Composition Quiz",
          "desc": "10 relationship examples. Students label each as aggregation, composition, association, or inheritance with a one-line reason.",
          "time": "10 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "OOP Principles & UML Basics covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Encapsulation, Inheritance, Polymorphism and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For OOP Principles & UML Basics, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for OOP Principles & UML Basics before choosing architecture primitives.",
            "Define boundaries for Encapsulation and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in OOP Principles & UML Basics; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Library System",
            "context": "Library System demands clear boundaries around Encapsulation and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Course Enrollment Model",
            "context": "Course Enrollment Model introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design oop principles & uml basics for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in oop principles & uml basics and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Encapsulation?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for oop principles & uml basics?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every OOP Principles & UML Basics answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Encapsulation is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 14,
      "module": "lld",
      "slug": "design-patterns-creational",
      "title": "Design Patterns: Creational",
      "topics": [
        "Factory",
        "Abstract Factory",
        "Singleton",
        "Builder",
        "Object creation decoupling"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Pattern Scavenger Hunt",
          "desc": "Open any popular open-source library. Find and name at least 2 creational patterns used in the codebase. Share findings.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Builder vs Constructor Comparison",
          "desc": "Implement a Pizza class: first with a telescoping constructor, then with Builder. Count parameters and compare readability.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Singleton Anti-pattern Lab",
          "desc": "Given a broken Singleton with thread-safety issues, students identify the race condition and fix it using double-checked locking.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Pattern Identification MCQ",
          "desc": "6 code snippets — identify which creational pattern each uses and what problem it solves.",
          "time": "10 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Design Patterns: Creational covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Factory, Abstract Factory, Singleton and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Design Patterns: Creational, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Design Patterns: Creational before choosing architecture primitives.",
            "Define boundaries for Factory and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Design Patterns: Creational; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Notification Builder",
            "context": "Notification Builder demands clear boundaries around Factory and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Multi-tenant Config Factory",
            "context": "Multi-tenant Config Factory introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design design patterns: creational for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in design patterns: creational and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Factory?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for design patterns: creational?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Design Patterns: Creational answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Factory is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 15,
      "module": "lld",
      "slug": "solid-principles",
      "title": "SOLID Principles",
      "topics": [
        "SRP",
        "OCP",
        "LSP",
        "ISP",
        "DIP",
        "Code smells",
        "Cohesion/coupling"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Code Smell Gallery Walk",
          "desc": "Post 5 code snippets around the room (or screen). Students rotate and annotate each with the SOLID principle being violated.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Refactor to SOLID",
          "desc": "Give a bloated God class. Students refactor it step-by-step: extract responsibilities, invert dependencies, and segregate interfaces.",
          "time": "35 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "LSP Litmus Test",
          "desc": "Show 5 inheritance hierarchies. Students apply the Liskov test: 'Can I replace the parent with this child without breaking behavior?'",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Design Review Memo",
          "desc": "Provide a 50-line class. Students write a short review identifying SOLID violations and proposing fixes.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "SOLID Principles covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding SRP, OCP, LSP and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For SOLID Principles, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for SOLID Principles before choosing architecture primitives.",
            "Define boundaries for SRP and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in SOLID Principles; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Billing Refactor",
            "context": "Billing Refactor demands clear boundaries around SRP and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Report Generator Cleanup",
            "context": "Report Generator Cleanup introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design solid principles for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in solid principles and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in SRP?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for solid principles?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every SOLID Principles answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how SRP is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 16,
      "module": "lld",
      "slug": "structural-patterns",
      "title": "Structural Patterns",
      "topics": [
        "Adapter",
        "Facade",
        "Composite",
        "Decorator",
        "Composition over inheritance"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Real-World Pattern Mapping",
          "desc": "Match each structural pattern to a real-world analog: Adapter = power plug converter, Facade = car dashboard... Students come up with their own.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Decorator Chain Builder",
          "desc": "Build a text formatter: plain → bold → italic → underline using the Decorator pattern. Show how decorators stack without modifying originals.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Adapter Design Challenge",
          "desc": "Given a legacy payment API and a new interface contract, design an Adapter that bridges them. Map each method and handle mismatches.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Pattern Selection Justification",
          "desc": "3 scenarios. Students choose the correct structural pattern and write a 2-sentence justification for each choice.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Structural Patterns covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Adapter, Facade, Composite and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Structural Patterns, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Structural Patterns before choosing architecture primitives.",
            "Define boundaries for Adapter and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Structural Patterns; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Payment Adapter",
            "context": "Payment Adapter demands clear boundaries around Adapter and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Facade for Legacy APIs",
            "context": "Facade for Legacy APIs introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design structural patterns for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in structural patterns and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Adapter?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for structural patterns?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Structural Patterns answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Adapter is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 17,
      "module": "lld",
      "slug": "behavioral-patterns-i",
      "title": "Behavioral Patterns I",
      "topics": [
        "Strategy",
        "Observer",
        "Command",
        "Event-driven interactions"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Strategy vs Hard-coding",
          "desc": "Show a sorting function with 4 if/else branches. Refactor live into Strategy. Count how many lines changed — and how many didn't.",
          "time": "20 min",
          "format": "Demo"
        },
        {
          "type": "intro",
          "title": "Observer Pattern Simulation",
          "desc": "Students model a notification system: one 'publisher' posts events, multiple 'subscribers' react differently. Draw the event flow and observer registration.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Command + Undo Implementation",
          "desc": "Design a text editor's undo/redo using Command pattern. Implement execute(), undo(), and a command history stack.",
          "time": "25 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Pattern Refactoring Task",
          "desc": "Given monolithic event handling code, refactor it using Observer or Command with a brief explanation of the design decision.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Behavioral Patterns I covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Strategy, Observer, Command and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Behavioral Patterns I, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Behavioral Patterns I before choosing architecture primitives.",
            "Define boundaries for Strategy and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Behavioral Patterns I; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Dynamic Pricing Strategy",
            "context": "Dynamic Pricing Strategy demands clear boundaries around Strategy and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Notification Observer",
            "context": "Notification Observer introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design behavioral patterns i for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in behavioral patterns i and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Strategy?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for behavioral patterns i?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Behavioral Patterns I answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Strategy is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 18,
      "module": "lld",
      "slug": "behavioral-patterns-ii",
      "title": "Behavioral Patterns II",
      "topics": [
        "State",
        "Chain of Responsibility",
        "Workflow handling",
        "Transaction modeling"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "State Machine Exploration",
          "desc": "Map out the states of a vending machine or traffic light on a whiteboard. Students discover they've drawn a State pattern without being told.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "State Transition Diagram",
          "desc": "Design a full State Machine for an order lifecycle: pending → confirmed → shipped → delivered → returned, with allowed transitions.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Chain of Responsibility Design",
          "desc": "Design a support ticket escalation: L1 → L2 → Manager → CEO. Implement handler chaining, early exit, and fallback.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Transaction Flow Modeling",
          "desc": "Model a payment transaction state machine with success, failure, retry, and timeout states. Include transitions and guard conditions.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Behavioral Patterns II covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding State, Chain of Responsibility, Workflow handling and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Behavioral Patterns II, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Behavioral Patterns II before choosing architecture primitives.",
            "Define boundaries for State and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Behavioral Patterns II; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Order Lifecycle State Machine",
            "context": "Order Lifecycle State Machine demands clear boundaries around State and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Escalation Workflow",
            "context": "Escalation Workflow introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design behavioral patterns ii for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in behavioral patterns ii and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in State?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for behavioral patterns ii?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Behavioral Patterns II answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how State is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 19,
      "module": "lld",
      "slug": "concurrency-in-lld",
      "title": "Concurrency in LLD",
      "topics": [
        "Mutex",
        "Semaphore",
        "Thread pools",
        "Deadlock",
        "Safe resource access"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Dining Philosophers Live",
          "desc": "5 students, 5 pencils, 5 plates of 'food'. Simulate the Dining Philosophers problem. Who deadlocks first? Then find the fix.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Mutex vs Semaphore Showdown",
          "desc": "Design 2 scenarios: one needs mutual exclusion, one needs resource counting. Implement both and explain why each choice is correct.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Thread Pool Sizing Calculator",
          "desc": "Given CPU-bound vs I/O-bound workloads, calculate optimal thread pool size using Little's Law and benchmark assumptions.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Deadlock Detection Drill",
          "desc": "Show 3 code snippets with concurrent resource acquisition. Identify which causes a deadlock and rewrite to fix it.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Concurrency in LLD covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Mutex, Semaphore, Thread pools and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Concurrency in LLD, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Concurrency in LLD before choosing architecture primitives.",
            "Define boundaries for Mutex and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Concurrency in LLD; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Worker Pool",
            "context": "Worker Pool demands clear boundaries around Mutex and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Inventory Locking",
            "context": "Inventory Locking introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design concurrency in lld for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in concurrency in lld and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Mutex?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for concurrency in lld?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Concurrency in LLD answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Mutex is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 20,
      "module": "lld",
      "slug": "extensible-system-design",
      "title": "Extensible System Design",
      "topics": [
        "Polymorphism",
        "Strategy-based rules",
        "Domain modeling",
        "Feature extensibility"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Feature Request Chaos",
          "desc": "Start with a simple discount calculator. Add 5 new requirements one by one. Watch the code collapse without extensibility. Then redesign.",
          "time": "20 min",
          "format": "Demo"
        },
        {
          "type": "intro",
          "title": "Polymorphic Discount Engine",
          "desc": "Design a discount system using polymorphism: PercentageDiscount, FixedDiscount, BuyOneGetOne. Add a new type without touching existing code.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Board Game Domain Model",
          "desc": "Model a board game engine (Chess or Checkers): pieces, moves, validation rules — designed for extensibility to new game types.",
          "time": "30 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Extensibility Checklist Review",
          "desc": "Review a provided design. Score it on: OCP compliance, polymorphism use, coupling level, ease of adding features. Give a 1-5 score with justification.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Extensible System Design covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Polymorphism, Strategy-based rules, Domain modeling and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Extensible System Design, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Extensible System Design before choosing architecture primitives.",
            "Define boundaries for Polymorphism and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Extensible System Design; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Discount Engine",
            "context": "Discount Engine demands clear boundaries around Polymorphism and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Rules-based Promotion",
            "context": "Rules-based Promotion introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design extensible system design for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in extensible system design and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Polymorphism?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for extensible system design?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Extensible System Design answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Polymorphism is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 21,
      "module": "lld",
      "slug": "persistence-and-repositories",
      "title": "Persistence & Repositories",
      "topics": [
        "Entity modeling",
        "Relationship mapping",
        "Transactions",
        "Repository pattern",
        "Service layer"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "ORM vs Raw SQL Debate",
          "desc": "Show the same query in ORM and raw SQL. Discuss: when does each shine? Where does ORM abstraction break down?",
          "time": "15 min",
          "format": "Discussion"
        },
        {
          "type": "intro",
          "title": "Repository Pattern Implementation",
          "desc": "Implement UserRepository with CRUD methods behind an interface. Show how the service layer never touches the DB directly.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Transaction Boundary Design",
          "desc": "Given a multi-step order creation flow (create order + deduct stock + charge payment), define transaction boundaries and rollback logic.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Layered Architecture Review",
          "desc": "Diagram a feature request end-to-end: Controller → Service → Repository → DB. Identify any layer violations or leaky abstractions.",
          "time": "15 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Persistence & Repositories covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Entity modeling, Relationship mapping, Transactions and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Persistence & Repositories, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Persistence & Repositories before choosing architecture primitives.",
            "Define boundaries for Entity modeling and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Persistence & Repositories; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Order Repository",
            "context": "Order Repository demands clear boundaries around Entity modeling and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Inventory Transaction Service",
            "context": "Inventory Transaction Service introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design persistence & repositories for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in persistence & repositories and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Entity modeling?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for persistence & repositories?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Persistence & Repositories answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Entity modeling is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 22,
      "module": "lld",
      "slug": "api-layer-and-error-handling",
      "title": "API Layer & Error Handling",
      "topics": [
        "REST endpoints",
        "Input validation",
        "Rate limiting",
        "HTTP codes",
        "Global error handling"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "HTTP Status Code Roulette",
          "desc": "Call 10 real public APIs with bad inputs. Log the status codes returned. Vote on which ones are correct, misleading, or lazy.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Error Handling Framework Design",
          "desc": "Design a global error handler: map exceptions to HTTP codes, define error response schema, and handle validation vs business vs infra errors differently.",
          "time": "25 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Rate Limiting Algorithm Comparison",
          "desc": "Implement token bucket and leaky bucket on paper for the same traffic pattern. Compare burst behavior and smoothness.",
          "time": "20 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "API Design Audit",
          "desc": "Review a provided REST API spec. Identify: missing validation, wrong status codes, unclear error messages, and security gaps.",
          "time": "20 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "API Layer & Error Handling covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding REST endpoints, Input validation, Rate limiting and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For API Layer & Error Handling, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for API Layer & Error Handling before choosing architecture primitives.",
            "Define boundaries for REST endpoints and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in API Layer & Error Handling; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Public API Gateway",
            "context": "Public API Gateway demands clear boundaries around REST endpoints and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Rate-Limited Billing API",
            "context": "Rate-Limited Billing API introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design api layer & error handling for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in api layer & error handling and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in REST endpoints?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for api layer & error handling?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every API Layer & Error Handling answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how REST endpoints is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 23,
      "module": "lld",
      "slug": "code-review-and-refactoring",
      "title": "Code Review & Refactoring",
      "topics": [
        "Design problems",
        "Modularization",
        "Naming conventions",
        "Readability",
        "Separation of concerns"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "WTF/Minute Code Review",
          "desc": "Display notoriously messy code. Students count their 'WTFs per minute' as a humorous proxy for code quality. Then identify fixes.",
          "time": "15 min",
          "format": "Group"
        },
        {
          "type": "intro",
          "title": "Refactoring Kata",
          "desc": "Give a working but messy function (e.g. a billing calculator). Students refactor it in stages: rename → extract → split → test-name → simplify.",
          "time": "30 min",
          "format": "Solo"
        },
        {
          "type": "practice",
          "title": "Peer Code Review Round",
          "desc": "Exchange code snippets with a partner. Write a structured code review covering: naming, cohesion, complexity, and testability.",
          "time": "25 min",
          "format": "Pairs"
        },
        {
          "type": "assess",
          "title": "Before/After Explanation",
          "desc": "Show a before and after refactoring. Students write a paragraph explaining what changed, why it's better, and what trade-offs were made.",
          "time": "10 min",
          "format": "Solo"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Code Review & Refactoring covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding Design problems, Modularization, Naming conventions and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Code Review & Refactoring, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Code Review & Refactoring before choosing architecture primitives.",
            "Define boundaries for Design problems and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Code Review & Refactoring; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Refactor Billing Module",
            "context": "Refactor Billing Module demands clear boundaries around Design problems and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Improve Checkout Readability",
            "context": "Improve Checkout Readability introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design code review & refactoring for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in code review & refactoring and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in Design problems?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for code review & refactoring?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Code Review & Refactoring answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how Design problems is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    },
    {
      "id": 24,
      "module": "lld",
      "slug": "capstone-lld-mock-interview",
      "title": "Capstone: LLD Mock Interview",
      "topics": [
        "End-to-end LLD",
        "OOP modeling",
        "Persistence",
        "Trade-offs",
        "Scalability"
      ],
      "estimatedReadMinutes": 10,
      "activities": [
        {
          "type": "spark",
          "title": "Warm-Up: 5-Min Sketch",
          "desc": "Give a simple problem (Parking Lot or ATM). 5 minutes, draw anything. No pressure — just get ideas on paper. Share and compare approaches.",
          "time": "10 min",
          "format": "Solo"
        },
        {
          "type": "intro",
          "title": "Structured Problem-Solving Framework",
          "desc": "Walk through the 5-step LLD interview approach: clarify → identify entities → design classes → add patterns → discuss trade-offs.",
          "time": "20 min",
          "format": "Group"
        },
        {
          "type": "practice",
          "title": "Full Mock Interview: 35 Min Design",
          "desc": "Choose one: Hotel Reservation, Ride Sharing, or Movie Booking. Design the full system: OOP model, persistence, API layer, and scalability notes.",
          "time": "35 min",
          "format": "Solo"
        },
        {
          "type": "assess",
          "title": "Design Presentation & Peer Critique",
          "desc": "Each student presents their capstone design for 5 minutes. Peers give structured feedback: 1 strength, 1 improvement, 1 question.",
          "time": "30 min",
          "format": "Group"
        }
      ],
      "activityTypes": [
        "spark",
        "intro",
        "practice",
        "assess"
      ],
      "sections": {
        "concepts": [
          {
            "heading": "What it is",
            "body": "Capstone: LLD Mock Interview covers the design decisions needed to build reliable systems and explain those decisions in interviews. The core focus is understanding End-to-end LLD, OOP modeling, Persistence and linking each concept to an architecture consequence."
          },
          {
            "heading": "Why it matters in interviews",
            "body": "Interviewers expect you to justify trade-offs, not just list tools. For Capstone: LLD Mock Interview, strong answers connect constraints, architecture choices, and failure behavior while staying explicit about what you would de-scope first."
          }
        ],
        "architecture": {
          "components": [
            "API Layer",
            "Controller",
            "Domain Model",
            "Service Layer",
            "Repository",
            "Database",
            "Policy Engine",
            "Observability"
          ],
          "flowSteps": [
            "Clarify scope and constraints for Capstone: LLD Mock Interview before choosing architecture primitives.",
            "Define boundaries for End-to-end LLD and map request/write paths.",
            "Introduce resilience points such as retries, idempotency, and observability checkpoints.",
            "Evaluate bottlenecks under peak load or feature expansion assumptions.",
            "Capture final trade-offs and explain why rejected alternatives were not selected."
          ],
          "diagramAscii": "Client --> API Layer --> Controller --> Service Layer\n                                     |\n                                     v\n                                Domain Model\n                                     |\n                                     v\n                                Repository --> Database\n                                     |\n                                     v\n                                Observability"
        },
        "tradeoffs": [
          {
            "decision": "Inheritance vs Composition",
            "optionA": "Deep inheritance hierarchy",
            "optionB": "Composed collaborators with interfaces",
            "chooseWhen": "Use composition by default in Capstone: LLD Mock Interview; use inheritance only for stable is-a relationships.",
            "risk": "Deep hierarchies are brittle and hard to evolve."
          },
          {
            "decision": "Extensibility vs Delivery Speed",
            "optionA": "Abstracted design with extension points",
            "optionB": "Direct implementation optimized for current scope",
            "chooseWhen": "Invest in extensibility if frequent feature variants are expected; keep it direct for short-lived or fixed-scope components.",
            "risk": "Over-abstraction slows delivery; under-abstraction creates future rewrite cost."
          },
          {
            "decision": "Strict Layering vs Pragmatic Access",
            "optionA": "Controller -> Service -> Repository only",
            "optionB": "Selective shortcuts for simple reads",
            "chooseWhen": "Use strict layering for larger teams and long-lived systems; allow shortcuts for isolated utility flows.",
            "risk": "Shortcuts can spread and weaken boundaries if not governed."
          },
          {
            "decision": "Runtime Flexibility vs Predictability",
            "optionA": "Plugin/strategy driven behavior",
            "optionB": "Static branching in code paths",
            "chooseWhen": "Use strategy plugins for high variation domains; use static paths when behavior is stable.",
            "risk": "Highly dynamic systems can be harder to debug and reason about."
          }
        ],
        "examples": [
          {
            "name": "Parking Lot Interview",
            "context": "Parking Lot Interview demands clear boundaries around End-to-end LLD and predictable behavior during peak usage.",
            "designChoice": "Use a staged design with a fast path and a durable path, then expose explicit fallback behavior to callers.",
            "why": "This keeps latency stable for normal traffic while preserving correctness for critical writes and failure recovery."
          },
          {
            "name": "Hotel Booking Interview",
            "context": "Hotel Booking Interview introduces changing requirements and forces design updates without breaking existing clients.",
            "designChoice": "Introduce stable interfaces, versioned contracts, and observability from the start so changes remain testable.",
            "why": "You can iterate safely while preserving backward compatibility and maintaining confidence in production behavior."
          }
        ],
        "interviewQa": [
          {
            "question": "How would you design capstone: lld mock interview for 10x growth?",
            "answerFramework": [
              "Clarify constraints and traffic shape",
              "Estimate scale and hotspots",
              "Propose baseline architecture",
              "Address bottlenecks and failure modes",
              "Explain final trade-offs"
            ]
          },
          {
            "question": "Which trade-off is most important in capstone: lld mock interview and why?",
            "answerFramework": [
              "State competing goals",
              "Choose one based on business risk",
              "Describe mitigation for the rejected option",
              "Define monitoring signals",
              "Describe revisit trigger"
            ]
          },
          {
            "question": "How do you handle failures in End-to-end LLD?",
            "answerFramework": [
              "Enumerate failure classes",
              "Add retries and idempotency boundaries",
              "Plan degraded behavior",
              "Protect data correctness",
              "Close with incident response approach"
            ]
          },
          {
            "question": "What would be your API and data model choices for capstone: lld mock interview?",
            "answerFramework": [
              "List key entities",
              "Define read/write patterns",
              "Choose consistency level",
              "Define pagination or batching strategy",
              "Cover evolution and versioning"
            ]
          },
          {
            "question": "How would you explain this design to a senior interviewer in 5 minutes?",
            "answerFramework": [
              "Start with requirements",
              "Show architecture and data flow",
              "Highlight critical trade-offs",
              "Call out failure handling",
              "Suggest future improvements"
            ]
          }
        ],
        "revision": {
          "cheatSheet": [
            "Start every Capstone: LLD Mock Interview answer with assumptions and limits.",
            "Name one latency-sensitive path and one correctness-sensitive path.",
            "State how End-to-end LLD is written and read under load.",
            "Explain one scaling strategy and one fallback strategy.",
            "Mention observability: metrics, logs, and tracing checkpoints.",
            "Call out a deliberate de-scope to keep MVP practical.",
            "Finish with what you would improve in version two."
          ],
          "redFlags": [
            "Choosing technology without linking it to constraints.",
            "Ignoring data consistency or idempotency for write operations.",
            "No failure-mode story for dependency outages.",
            "No plan to measure whether the design is actually working."
          ]
        }
      }
    }
  ]
}
